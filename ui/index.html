<!DOCTYPE html>
<html>
<head>
    <title>NATS JetStream Monitor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .info-box {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .info-box h2 {
            margin-top: 0;
            color: #495057;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat-card {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #0d6efd;
        }
        .stat-label {
            font-size: 14px;
            color: #6c757d;
        }
        .refresh-btn {
            background-color: #0d6efd;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            display: block;
            margin: 20px auto;
        }
        .refresh-btn:hover {
            background-color: #0b5ed7;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .status-ok {
            color: #28a745;
            font-weight: bold;
        }
        .status-warning {
            color: #ffc107;
            font-weight: bold;
        }
        .status-error {
            color: #dc3545;
            font-weight: bold;
        }
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            max-height: 400px;
        }
        .message-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
        }
        .message-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
        }
        .message-item:last-child {
            border-bottom: none;
        }
        .message-header {
            font-weight: bold;
            color: #0d6efd;
        }
        .message-timestamp {
            font-size: 0.8em;
            color: #6c757d;
        }
        .auto-refresh {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .auto-refresh input {
            margin-right: 5px;
        }
        .consumer-status-active {
            background-color: #d4edda;
            color: #155724;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        .consumer-status-inactive {
            background-color: #f8d7da;
            color: #721c24;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        .consumer-status-pending {
            background-color: #fff3cd;
            color: #856404;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        .disconnect-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .disconnect-btn:hover {
            background-color: #c82333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>NATS JetStream Monitor</h1>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="server-version">-</div>
                <div class="stat-label">Server Version</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="connections">-</div>
                <div class="stat-label">Connections</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="subscriptions">-</div>
                <div class="stat-label">Subscriptions</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="messages">-</div>
                <div class="stat-label">Messages</div>
            </div>
        </div>
        
        <div class="auto-refresh">
            <input type="checkbox" id="auto-refresh" checked>
            <label for="auto-refresh">Auto-refresh every 5 seconds</label>
            <button class="refresh-btn" onclick="refreshData()">Refresh Data</button>
        </div>
        
        <div class="info-box">
            <h2>Server Information</h2>
            <pre id="server-info">Loading...</pre>
        </div>
        
        <div class="info-box">
            <h2>JetStream Information</h2>
            <pre id="jetstream-info">Loading...</pre>
        </div>
        
        <div class="info-box">
            <h2>Connected Clients</h2>
            <table id="clients-table">
                <thead>
                    <tr>
                        <th>Client ID</th>
                        <th>Name</th>
                        <th>Language</th>
                        <th>Version</th>
                        <th>IP Address</th>
                        <th>Subscriptions</th>
                    </tr>
                </thead>
                <tbody id="clients-table-body">
                    <tr>
                        <td colspan="6">Loading...</td>
                    </tr>
                </tbody>
            </table>
            
        </div>
        
        <div class="info-box">
            <h2>Consumer Processes</h2>
            <table id="processes-table">
                <thead>
                    <tr>
                        <th>Process ID</th>
                        <th>Name</th>
                        <th>Command</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="processes-table-body">
                    <tr>
                        <td colspan="4">Loading...</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="info-box">
            <h2>Stream Information</h2>
            <div id="stream-info">Loading...</div>
        </div>
        
        <div class="info-box">
            <h2>Consumers</h2>
            <div id="consumers-info">Loading...</div>
        </div>
        
        <div class="info-box">
            <h2>KV Leases</h2>
            <div id="kv-leases-info">Loading...</div>
        </div>
        
        <div class="info-box">
            <h2>Latest KV Lease Events (10 most recent)</h2>
            <div id="kv-lease-details">Loading...</div>
        </div>
        
        <div class="info-box">
            <h2>Consumer Status Updates</h2>
            <div class="auto-refresh">
                <input type="checkbox" id="monitor-messages" onchange="toggleMessageMonitoring()">
                <label for="monitor-messages">Monitor consumer status</label>
            </div>
            <div id="message-monitor" style="display: none;">
                <p>Consumer status updates will appear here as they arrive.</p>
                <div class="message-list" id="message-list"></div>
            </div>
        </div>
        
        <div class="info-box">
            <h2>Recent Stream Messages</h2>
            <div class="auto-refresh">
                <input type="checkbox" id="monitor-stream-messages" onchange="toggleStreamMessageMonitoring()">
                <label for="monitor-stream-messages">Monitor stream messages</label>
            </div>
            <div id="stream-message-monitor" style="display: none;">
                <p>Actual stream messages will appear here as they arrive.</p>
                <div class="message-list" id="stream-message-list"></div>
            </div>
        </div>
        
        <div class="info-box">
            <h2>Running the Applications</h2>
            <p>To see the full monitoring capabilities in action:</p>
            <ol>
                <li><strong>Start a consumer:</strong> Run <code>make run-consumer</code> in a terminal</li>
                <li><strong>Start a publisher:</strong> Run <code>make run-publisher</code> in another terminal</li>
                <li><strong>Monitor the UI:</strong> Refresh this page to see updated statistics</li>
            </ol>
            <p>You can run multiple consumers to see the lease-based coordination in action.</p>
        </div>
        
        <div class="info-box">
            <h2>Subscriptions</h2>
            <div id="subscriptions-info">Loading...</div>
        </div>
</body>
</html>
    </div>

    <script>
        // Global variables
        let messageMonitoringEnabled = false;
        let streamMessageMonitoringEnabled = false;
        let messageCount = 0;
        const maxMessages = 50; // Limit to last 50 messages
        
        // Function to fetch data from APIs
        async function fetchData(endpoint) {
            try {
                // For process management APIs, use port 8082
                let url = endpoint;
                if (endpoint === '/api/processes' || endpoint.startsWith('/api/kill') || endpoint === '/api/kv-leases' || endpoint === '/api/delete-stream' || endpoint === '/api/stream-messages') {
                    url = 'http://localhost:8082' + endpoint;
                }
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error('Error fetching data:', error);
                return { error: 'Failed to fetch data: ' + error.message };
            }
        }
        
        // Function to format bytes to human readable format
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Function to format date
        function formatDate(dateString) {
            if (!dateString) return 'Never';
            const date = new Date(dateString);
            return date.toLocaleString();
        }
        
        // Function to determine consumer status
        function getConsumerStatus(consumer) {
            const ackPending = consumer.num_ack_pending || 0;
            const pending = consumer.num_pending || 0;
            const delivered = consumer.delivered?.stream_seq || 0;
            const ackFloor = consumer.ack_floor?.stream_seq || 0;
            
            // Check if consumer has been active recently (within last 30 seconds)
            let isActive = false;
            let timeSinceLastActivity = null;
            if (consumer.ts) {
                const lastActive = new Date(consumer.ts);
                const now = new Date();
                timeSinceLastActivity = Math.floor((now - lastActive) / 1000); // in seconds
                isActive = timeSinceLastActivity < 30; // active if last activity was within 30 seconds
            }
            
            if (ackPending > 10 || (delivered - ackFloor) > 10) {
                return { status: 'Delayed', class: 'consumer-status-pending' };
            } else if (pending > 0 || isActive) {
                return { status: 'Active', class: 'consumer-status-active' };
            } else if (timeSinceLastActivity !== null && timeSinceLastActivity < 300) { // Less than 5 minutes
                return { status: 'Recently Active', class: 'consumer-status-active' };
            } else {
                return { status: 'Idle', class: 'consumer-status-inactive' };
            }
        }
        
        // Function to add a message to the display
        function addMessageToDisplay(subject, data, timestamp) {
            const messageList = document.getElementById('message-list');
            const messageItem = document.createElement('div');
            messageItem.className = 'message-item';
            messageItem.innerHTML = `
                <div class="message-header">${subject}</div>
                <div class="message-timestamp">${new Date(timestamp).toLocaleString()}</div>
                <div class="message-data">${data}</div>
            `;
            
            // Add to top of list
            if (messageList.firstChild) {
                messageList.insertBefore(messageItem, messageList.firstChild);
            } else {
                messageList.appendChild(messageItem);
            }
            
            // Limit to maxMessages
            while (messageList.children.length > maxMessages) {
                messageList.removeChild(messageList.lastChild);
            }
        }
        
        // Function to connect to NATS WebSocket for real-time message monitoring
        let wsConnection = null;
        
        function connectMessageMonitoring() {
            if (!messageMonitoringEnabled) return;
            
            try {
                // Note: Real NATS WebSocket monitoring would require NATS WebSocket support
                // For now, we'll periodically check for new messages via the monitoring API
                monitorMessages();
            } catch (error) {
                console.error('Failed to connect message monitoring:', error);
                document.getElementById('message-list').innerHTML = '<div class="message-item">Message monitoring unavailable</div>';
            }
        }
        
        let lastStreamSeq = 0;
        
        async function monitorMessages() {
            if (!messageMonitoringEnabled) return;
            
            try {
                // Poll JetStream for new messages by checking stream sequence numbers
                const jsz = await fetchData('/api/v1/jsz?streams=true&consumers=true');
                const messageList = document.getElementById('message-list');
                
                if (jsz.account_details && jsz.account_details.length > 0) {
                    const account = jsz.account_details[0];
                    let hasNewMessages = false;
                    
                    if (account.stream_detail) {
                        account.stream_detail.forEach(stream => {
                            if (stream.name === 'stream_name' && stream.state) {
                                const currentSeq = stream.state.last_seq || 0;
                                const messageCount = stream.state.messages || 0;
                                
                                if (currentSeq > lastStreamSeq) {
                                    const newMessages = currentSeq - lastStreamSeq;
                                    addMessageToDisplay(
                                        `Stream Update`,
                                        `${newMessages} new message(s) processed (seq: ${lastStreamSeq + 1}-${currentSeq})`,
                                        stream.state.last_ts || new Date().toISOString()
                                    );
                                    lastStreamSeq = currentSeq;
                                    hasNewMessages = true;
                                }
                                
                                // Show consumer activity
                                if (stream.consumer_detail) {
                                    stream.consumer_detail.forEach(consumer => {
                                        const pending = consumer.num_pending || 0;
                                        const waiting = consumer.num_waiting || 0;
                                        if (pending > 0 || waiting > 0) {
                                            addMessageToDisplay(
                                                `Consumer Status Update`,
                                                `Consumer ${consumer.name}: ${pending} pending, ${waiting} waiting`,
                                                consumer.ts || new Date().toISOString()
                                            );
                                        }
                                    });
                                }
                            }
                        });
                    }
                    
                    if (!hasNewMessages && messageList.children.length === 0) {
                        messageList.innerHTML = '<div class="message-item">No new activity. Consumers are running and waiting for messages. Start publisher with <code>make run-publisher</code> to generate messages.</div>';
                    }
                } else {
                    messageList.innerHTML = '<div class="message-item">No JetStream data available</div>';
                }
                
                // Continue monitoring
                if (messageMonitoringEnabled) {
                    setTimeout(monitorMessages, 2000);
                }
            } catch (error) {
                console.error('Message monitoring error:', error);
                const messageList = document.getElementById('message-list');
                messageList.innerHTML = '<div class="message-item">Error monitoring messages: ' + error.message + '</div>';
            }
        }
        
        // Function to disconnect a client
        async function disconnectClient(clientId) {
            if (!confirm(`Are you sure you want to disconnect client ${clientId}?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/v1/connz?cid=${clientId}&close=true`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    alert(`Client ${clientId} disconnected successfully`);
                    // Refresh the data to show updated connection list
                    refreshData();
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error('Error disconnecting client:', error);
                alert(`Failed to disconnect client ${clientId}: ${error.message}`);
            }
        }
        
        // Function to kill a process by PID
        async function killProcess(pid) {
            if (!confirm(`Are you sure you want to KILL process ${pid}? This will terminate the consumer immediately.`)) {
                return;
            }
            
            try {
                const response = await fetch(`http://localhost:8082/api/kill`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ pid: pid })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    alert(result.message);
                    // Refresh the data to show updated process list
                    refreshData();
                } else {
                    const error = await response.text();
                    throw new Error(`HTTP ${response.status}: ${error}`);
                }
            } catch (error) {
                console.error('Error killing process:', error);
                alert(`Failed to kill process ${pid}: ${error.message}`);
            }
        }
        
        // Function to delete a stream
        async function deleteStream(streamName) {
            if (!confirm(`Are you sure you want to DELETE stream ${streamName}? This will permanently remove all messages in the stream.`)) {
                return;
            }
            
            try {
                const response = await fetch(`http://localhost:8082/api/delete-stream`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ stream_name: streamName })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    alert(result.message);
                    // Refresh the data to show updated stream list
                    refreshData();
                } else {
                    const error = await response.text();
                    throw new Error(`HTTP ${response.status}: ${error}`);
                }
            } catch (error) {
                console.error('Error deleting stream:', error);
                alert(`Failed to delete stream ${streamName}: ${error.message}`);
            }
        }
        
        // Function to toggle message monitoring
        function toggleMessageMonitoring() {
            messageMonitoringEnabled = document.getElementById('monitor-messages').checked;
            const messageMonitor = document.getElementById('message-monitor');
            
            if (messageMonitoringEnabled) {
                messageMonitor.style.display = 'block';
                connectMessageMonitoring();
            } else {
                messageMonitor.style.display = 'none';
                if (wsConnection) {
                    wsConnection.close();
                    wsConnection = null;
                }
            }
        }
        
        // Function to toggle stream message monitoring
        function toggleStreamMessageMonitoring() {
            streamMessageMonitoringEnabled = document.getElementById('monitor-stream-messages').checked;
            const streamMessageMonitor = document.getElementById('stream-message-monitor');
            
            if (streamMessageMonitoringEnabled) {
                streamMessageMonitor.style.display = 'block';
                monitorStreamMessages();
            } else {
                streamMessageMonitor.style.display = 'none';
            }
        }
        
        // Function to monitor actual stream messages
        async function monitorStreamMessages() {
            if (!streamMessageMonitoringEnabled) return;
            
            try {
                const response = await fetch('http://localhost:8082/api/stream-messages');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const messages = await response.json();
                
                const messageList = document.getElementById('stream-message-list');
                if (messages.length === 0) {
                    messageList.innerHTML = '<div class="message-item">No messages found in stream</div>';
                } else {
                    messageList.innerHTML = '';
                    messages.forEach(msg => {
                        const messageItem = document.createElement('div');
                        messageItem.className = 'message-item';
                        messageItem.innerHTML = `
                            <div class="message-header">${msg.subject || 'No Subject'}</div>
                            <div class="message-timestamp">Seq: ${msg.seq} - ${msg.time || 'Unknown time'}</div>
                            <div class="message-data"><pre>${msg.data || 'No data'}</pre></div>
                            ${Object.keys(msg.headers || {}).length > 0 ? 
                                `<div class="message-headers">Headers: ${JSON.stringify(msg.headers)}</div>` : ''}
                        `;
                        messageList.appendChild(messageItem);
                    });
                }
                
                // Continue monitoring
                if (streamMessageMonitoringEnabled) {
                    setTimeout(monitorStreamMessages, 5000); // Refresh every 5 seconds
                }
            } catch (error) {
                console.error('Stream message monitoring error:', error);
                const messageList = document.getElementById('stream-message-list');
                messageList.innerHTML = '<div class="message-item">Error monitoring stream messages: ' + error.message + '</div>';
            }
        }
        
        // Function to refresh all data
        async function refreshData() {
            try {
                // Update server info
                const varz = await fetchData('/api/v1/varz');
                if (varz.error) {
                    document.getElementById('server-info').textContent = JSON.stringify(varz, null, 2);
                } else {
                    document.getElementById('server-info').textContent = JSON.stringify(varz, null, 2);
                    document.getElementById('server-version').textContent = varz.version || '-';
                    document.getElementById('connections').textContent = varz.connections || '-';
                    document.getElementById('subscriptions').textContent = varz.subscriptions || '-';
                }
                
                // Update JetStream info
                const jsz = await fetchData('/api/v1/jsz');
                if (jsz.error) {
                    document.getElementById('jetstream-info').textContent = JSON.stringify(jsz, null, 2);
                } else {
                    document.getElementById('jetstream-info').textContent = JSON.stringify(jsz, null, 2);
                    document.getElementById('messages').textContent = jsz.messages || '-';
                }
                
                // Update clients table
                const connz = await fetchData('/api/v1/connz');
                if (connz.error) {
                    document.getElementById('clients-table-body').innerHTML = `<tr><td colspan="6">${JSON.stringify(connz, null, 2)}</td></tr>`;
                } else {
                    const connections = connz.connections || [];
                    const tbody = document.getElementById('clients-table-body');
                    if (connections.length === 0) {
                        tbody.innerHTML = '<tr><td colspan="6">No active connections</td></tr>';
                    } else {
                        tbody.innerHTML = connections.map(conn => `
                            <tr>
                                <td>${conn.cid || '-'}</td>
                                <td>${conn.name || '-'}</td>
                                <td>${conn.lang || '-'}</td>
                                <td>${conn.version || '-'}</td>
                                <td>${conn.ip || '-'}</td>
                                <td>${conn.subscriptions || '-'}</td>
                            </tr>
                        `).join('');
                    }
                }
                
                
                // Update subscriptions info from NATS monitoring data
                const subsInfo = document.getElementById('subscriptions-info');
                if (connz.error) {
                    subsInfo.innerHTML = `<p>Error loading subscriptions: ${connz.error}</p>`;
                } else if (connz.connections && connz.connections.length > 0) {
                    // Count total subscriptions from connection data
                    let totalSubs = 0;
                    connz.connections.forEach(conn => {
                        if (conn.subscriptions_list && conn.subscriptions_list.length > 0) {
                            totalSubs += conn.subscriptions_list.length;
                        }
                    });
                    
                    if (totalSubs > 0) {
                        let subscriptionsHtml = `
                            <p>Showing ${totalSubs} subscription(s) from ${connz.connections.length} connection(s)</p>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Subject</th>
                                        <th>Queue Group</th>
                                        <th>Client ID</th>
                                        <th>Messages In</th>
                                        <th>Messages Out</th>
                                    </tr>
                                </thead>
                                <tbody>`;
                        
                        connz.connections.forEach(conn => {
                            if (conn.subscriptions_list && conn.subscriptions_list.length > 0) {
                                conn.subscriptions_list.forEach(sub => {
                                    subscriptionsHtml += `
                                        <tr>
                                            <td>${sub.subject || 'N/A'}</td>
                                            <td>${sub.qgroup || 'N/A'}</td>
                                            <td>${conn.cid || 'N/A'}</td>
                                            <td>${conn.in_msgs || 0}</td>
                                            <td>${conn.out_msgs || 0}</td>
                                        </tr>`;
                                });
                            }
                        });
                        
                        subscriptionsHtml += `</tbody></table>`;
                        subsInfo.innerHTML = subscriptionsHtml;
                    } else {
                        subsInfo.innerHTML = `<p>No detailed subscription information available. Total subscriptions: ${varz.subscriptions || 0}</p>`;
                    }
                } else {
                    subsInfo.innerHTML = '<p>No active connections found.</p>';
                }                // Show stream information from jsz with detailed stream data
                const jszDetailData = await fetchData('/api/v1/jsz?streams=true');
                if (jszDetailData.error) {
                    document.getElementById('stream-info').innerHTML = `<pre>Error: ${JSON.stringify(jszDetailData, null, 2)}</pre>`;
                } else if (jszDetailData.account_details && jszDetailData.account_details.length > 0) {
                    const account = jszDetailData.account_details[0];
                    if (account.stream_detail && account.stream_detail.length > 0) {
                        let streamHtml = `
                            <table>
                                <thead>
                                    <tr>
                                        <th>Stream Name</th>
                                        <th>Messages</th>
                                        <th>Size</th>
                                        <th>Consumers</th>
                                        <th>Subjects</th>
                                        <th>Last Sequence</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>`;
                        
                        account.stream_detail.forEach(stream => {
                            streamHtml += `
                                <tr>
                                    <td>${stream.name || 'N/A'}</td>
                                    <td>${stream.state?.messages || 0}</td>
                                    <td>${formatBytes(stream.state?.bytes || 0)}</td>
                                    <td>${stream.state?.consumer_count || 0}</td>
                                    <td>${stream.config?.subjects ? stream.config.subjects.join(', ') : 'N/A'}</td>
                                    <td>${stream.state?.last_seq || 0}</td>
                                    <td><button class="disconnect-btn" onclick="deleteStream('${stream.name}')">Delete</button></td>
                                </tr>`;
                        });
                        
                        streamHtml += `</tbody></table>`;
                        
                        document.getElementById('stream-info').innerHTML = streamHtml;
                    } else {
                        document.getElementById('stream-info').innerHTML = '<p>No streams found or no stream details available.</p>';
                    }
                } else {
                    document.getElementById('stream-info').innerHTML = '<p>JetStream not enabled or no account details available.</p>';
                }
                
                // Show consumers information from detailed JetStream data
                const jszConsumerData = await fetchData('/api/v1/jsz?consumers=true');
                if (jszConsumerData.error) {
                    document.getElementById('consumers-info').innerHTML = `<pre>Error: ${JSON.stringify(jszConsumerData, null, 2)}</pre>`;
                } else if (jszConsumerData.account_details && jszConsumerData.account_details.length > 0) {
                    const account = jszConsumerData.account_details[0];
                    let consumersHtml = `
                        <table>
                            <thead>
                                <tr>
                                    <th>Consumer Name</th>
                                    <th>Stream</th>
                                    <th>Delivered</th>
                                    <th>Ack Floor</th>
                                    <th>Pending</th>
                                    <th>Status</th>
                                    <th>Last Active</th>
                                </tr>
                            </thead>
                            <tbody>`;
                    
                    let hasConsumers = false;
                    if (account.stream_detail) {
                        account.stream_detail.forEach(stream => {
                            if (stream.consumer_detail && stream.consumer_detail.length > 0) {
                                stream.consumer_detail.forEach(consumer => {
                                    hasConsumers = true;
                                    const status = getConsumerStatus(consumer);
                                    consumersHtml += `
                                        <tr>
                                            <td>${consumer.name || 'N/A'}</td>
                                            <td>${stream.name || 'N/A'}</td>
                                            <td>${consumer.delivered?.stream_seq || 0}</td>
                                            <td>${consumer.ack_floor?.stream_seq || 0}</td>
                                            <td>${consumer.num_pending || 0}</td>
                                            <td><span class="${status.class}">${status.status}</span></td>
                                            <td>${formatDate(consumer.ts)}</td>
                                        </tr>`;
                                });
                            }
                        });
                    }
                    
                    if (!hasConsumers) {
                        consumersHtml += '<tr><td colspan="7">No consumers found</td></tr>';
                    }
                    
                    consumersHtml += '</tbody></table>';
                    document.getElementById('consumers-info').innerHTML = consumersHtml;
                } else {
                    document.getElementById('consumers-info').innerHTML = '<p>No consumer information available.</p>';
                }
                
                // Show KV leases information - look for KV buckets from detailed stream data
                if (jszDetailData.account_details && jszDetailData.account_details.length > 0) {
                    const account = jszDetailData.account_details[0];
                    let kvHtml = `
                        <table>
                            <thead>
                                <tr>
                                    <th>KV Bucket</th>
                                    <th>Stream</th>
                                    <th>Keys (Messages)</th>
                                    <th>Size</th>
                                    <th>Last Update</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>`;
                    
                    let hasKvBuckets = false;
                    if (account.stream_detail) {
                        account.stream_detail.forEach(stream => {
                            // KV buckets typically start with 'KV_' prefix
                            if (stream.name && stream.name.startsWith('KV_')) {
                                hasKvBuckets = true;
                                const bucketName = stream.name.substring(3); // Remove 'KV_' prefix
                                kvHtml += `
                                    <tr>
                                        <td>${bucketName}</td>
                                        <td>${stream.name}</td>
                                        <td>${stream.state?.messages || 0}</td>
                                        <td>${formatBytes(stream.state?.bytes || 0)}</td>
                                        <td>${formatDate(stream.state?.last_ts) || 'Never'}</td>
                                        <td><span class="consumer-status-active">Active</span></td>
                                    </tr>`;
                            }
                        });
                    }
                    
                    if (!hasKvBuckets) {
                        kvHtml += '<tr><td colspan="6">No KV buckets found</td></tr>';
                    }
                    
                    kvHtml += '</tbody></table>';
                    document.getElementById('kv-leases-info').innerHTML = kvHtml;
                } else {
                    document.getElementById('kv-leases-info').innerHTML = '<p>No KV bucket information available.</p>';
                }
                
                // Update processes table
                try {
                    const processes = await fetchData('/api/processes');
                    if (processes.error) {
                        document.getElementById('processes-table-body').innerHTML = `<tr><td colspan="4">Error: ${processes.error}</td></tr>`;
                    } else {
                        const tbody = document.getElementById('processes-table-body');
                        if (processes.length === 0) {
                            tbody.innerHTML = '<tr><td colspan="4">No consumer processes running</td></tr>';
                        } else {
                            tbody.innerHTML = processes.map(proc => `
                                <tr>
                                    <td>${proc.pid}</td>
                                    <td>${proc.name}</td>
                                    <td style="font-family: monospace; font-size: 11px; max-width: 300px; overflow: hidden; text-overflow: ellipsis;">${proc.command || 'N/A'}</td>
                                    <td>
                                        <button class="disconnect-btn" onclick="killProcess(${proc.pid})">
                                            Kill PID
                                        </button>
                                    </td>
                                </tr>
                            `).join('');
                        }
                    }
                } catch (error) {
                    console.error('Error loading processes:', error);
                    document.getElementById('processes-table-body').innerHTML = `<tr><td colspan="4">Failed to load processes</td></tr>`;
                }
                
                // Load detailed KV lease contents
                try {
                    const kvDetails = await fetchData('/api/kv-leases');
                    if (kvDetails.error) {
                        document.getElementById('kv-lease-details').innerHTML = `<p>Error loading KV details: ${kvDetails.error}</p>`;
                    } else {
                        // Display KV entries in a clean table
                        let detailsHtml = `
                            <table>
                                <thead>
                                    <tr>
                                        <th>Key</th>
                                        <th>Type</th>
                                        <th>Value</th>
                                    </tr>
                                </thead>
                                <tbody>`;
                        
                        if (kvDetails.length === 0) {
                            detailsHtml += '<tr><td colspan="3">No KV entries found</td></tr>';
                        } else {
                            // Take the most recent entries (last 10) and display them in reverse order (newest first)
                            let recentEntries = kvDetails;
                            if (kvDetails.length > 10) {
                                recentEntries = kvDetails.slice(-10); // Get the last 10 entries
                            }
                            
                            // Reverse the order to show newest first
                            const sortedDetails = recentEntries.reverse();
                            
                            sortedDetails.forEach(entry => {
                                let valueDisplay = '';
                                let type = 'String';
                                
                                if (typeof entry.value === 'object') {
                                    type = 'JSON';
                                    if (entry.value.worker_id && entry.value.last_seen) {
                                        // Worker registration
                                        const lastSeen = new Date(entry.value.last_seen);
                                        const isRecent = (new Date() - lastSeen) < 30000; // Less than 30 seconds
                                        const status = isRecent ? 'ðŸŸ¢ Active' : 'ðŸŸ¡ Stale';
                                        valueDisplay = `
                                            <div style="font-size: 12px;">
                                                <div><strong>Worker:</strong> ${entry.value.worker_id}</div>
                                                <div><strong>Status:</strong> ${status}</div>
                                                <div><strong>Last Seen:</strong> ${lastSeen.toLocaleString()}</div>
                                                ${entry.value.partitions ? `<div><strong>Partitions:</strong> [${entry.value.partitions.join(', ')}]</div>` : ''}
                                            </div>
                                        `;
                                        type = 'Worker';
                                    } else if (entry.value.worker_id && entry.value.expires_at) {
                                        // Lease entry
                                        const expiresAt = new Date(entry.value.expires_at);
                                        const isActive = expiresAt > new Date();
                                        const status = isActive ? 'ðŸŸ¢ Active' : 'ðŸ”´ Expired';
                                        const timeLeft = isActive ? Math.ceil((expiresAt - new Date()) / 1000) : 0;
                                        valueDisplay = `
                                            <div style="font-size: 12px;">
                                                <div><strong>Owner:</strong> ${entry.value.worker_id}</div>
                                                <div><strong>Status:</strong> ${status}</div>
                                                <div><strong>Expires:</strong> ${expiresAt.toLocaleString()}</div>
                                                ${isActive ? `<div><strong>Time Left:</strong> ${timeLeft}s</div>` : ''}
                                            </div>
                                        `;
                                        type = 'Lease';
                                    } else {
                                        valueDisplay = `<pre style="margin: 0; font-size: 11px; max-height: 100px; overflow-y: auto;">${JSON.stringify(entry.value, null, 2)}</pre>`;
                                        type = 'JSON';
                                    }
                                } else {
                                    valueDisplay = String(entry.value);
                                }
                                
                                detailsHtml += `
                                    <tr>
                                        <td style="font-family: monospace; font-weight: bold;">${entry.key}</td>
                                        <td><span style="background: #e9ecef; padding: 2px 6px; border-radius: 3px; font-size: 11px;">${type}</span></td>
                                        <td style="max-width: 400px;">${valueDisplay}</td>
                                    </tr>`;
                            });
                        }
                        
                        detailsHtml += '</tbody></table>';
                        document.getElementById('kv-lease-details').innerHTML = detailsHtml;
                    }
                } catch (error) {
                    console.error('Error loading KV details:', error);
                    document.getElementById('kv-lease-details').innerHTML = `<p>Failed to load KV details: ${error.message}</p>`;
                }
            } catch (error) {
                console.error('Error refreshing data:', error);
            }
        }
        
        // Initial data load
        refreshData();
        
        // Auto-refresh based on checkbox
        setInterval(() => {
            if (document.getElementById('auto-refresh') && document.getElementById('auto-refresh').checked) {
                refreshData();
            }
        }, 5000);
    </script>
</body>
</html>